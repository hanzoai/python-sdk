"""End-to-end workflow sanity tests for planning→tasks→Linear→worktrees.

These tests validate that hanzo-mcp can orchestrate the requested flow using
existing tools without requiring networked services:
- Architecture proposal via LLM (mocked)
- Task generation from proposal via LLM (mocked)
- Linear MCP server registration via mcp_add + visibility in mcp_stats
- Per-task git worktree creation via bash

Network calls are not performed. LLM calls are mocked via litellm patching.
"""

from __future__ import annotations

import os
import json

# Ensure typing.override exists on Python < 3.12
import typing as _typing
import tempfile
import subprocess
from typing import Any, Dict
from pathlib import Path

import pytest

if not hasattr(_typing, "override"):

    def _override(obj):  # type: ignore
        return obj

    _typing.override = _override  # type: ignore[attr-defined]

from test_utils import PermissionManager
from mcp.server.fastmcp import Context as MCPContext

# Import MCP tools after making sure typing.override is available
from hanzo_mcp.tools.mcp.mcp_add import McpAddTool
from hanzo_mcp.tools.llm.llm_tool import LLMTool
from hanzo_mcp.tools.mcp.mcp_stats import McpStatsTool
from hanzo_mcp.tools.shell.bash_tool import BashTool


def _mock_acompletion_factory(responses: Dict[str, str]):
    """Create a litellm.acompletion mock that returns responses by keyword.

    The first matching keyword in the prompt determines the returned text.
    Defaults to a simple echo if nothing matches.
    """

    class _MockResponse:
        def __init__(self, text: str):
            self.choices = [type("C", (), {"message": type("M", (), {"content": text})()})]

    async def _acompletion(**kwargs):  # type: ignore
        prompt = "".join(
            part
            for part in (
                kwargs.get("messages", [{}])[-1].get("content"),
                kwargs.get("prompt"),
            )
            if part
        )
        for key, value in responses.items():
            if key.lower() in (prompt or "").lower():
                return _MockResponse(value)
        return _MockResponse("OK")

    async def _astream(**kwargs):  # pragma: no cover - not used
        return

    return _acompletion, _astream


@pytest.mark.asyncio
async def test_architecture_and_task_gen_with_consensus_mock(monkeypatch, tmp_path: Path):
    """Architecture → tasks flow using LLMTool with litellm mocked.

    - Generates an architecture.md file
    - Generates JSON tasks from the architecture
    """

    # LLM responses will be generated by LLMTool fast-test mode

    # Tools and context
    ctx = MCPContext()
    # Isolate server registry by scoping HOME to tmp_path
    os.environ["HOME"] = str(tmp_path)
    # Ensure provider check passes
    os.environ["OPENAI_API_KEY"] = "test-key"
    permission_manager = PermissionManager()
    permission_manager._allowed_paths.add(str(tmp_path))
    llm = LLMTool()

    # 1) Architecture proposal
    arch_file = tmp_path / "architecture.md"
    result1 = await llm.call(
        ctx,
        action="query",
        prompt="Create architecture for service (architecture)",
        model="gpt-4o",
    )
    arch_file.write_text(str(result1))
    assert arch_file.read_text().startswith("Architecture Proposal")

    # 2) Task generation from architecture doc
    result2 = await llm.call(
        ctx,
        action="query",
        prompt=f"Read {arch_file} and generate tasks as JSON (generate tasks)",
        model="gpt-4o",
    )
    data = json.loads(str(result2))
    assert "tasks" in data and len(data["tasks"]) >= 2


@pytest.mark.asyncio
async def test_register_linear_mcp_and_list_in_stats(tmp_path: Path):
    """Add a Linear MCP server and confirm it shows in stats output."""

    ctx = MCPContext()
    # Patch tool context to have async set_tool_info
    import hanzo_mcp.tools.mcp.mcp_add as mcp_add_mod
    import hanzo_mcp.tools.mcp.mcp_stats as mcp_stats_mod
    from hanzo_mcp.tools.common import context as ctx_mod

    class _StubToolCtx:
        async def set_tool_info(self, *args, **kwargs):
            return None

        async def info(self, *args, **kwargs):
            return None

        async def error(self, *args, **kwargs):
            return None

    ctx_mod.create_tool_context = lambda _ctx: _StubToolCtx()  # type: ignore
    mcp_add_mod.create_tool_context = lambda _ctx: _StubToolCtx()  # type: ignore
    mcp_stats_mod.create_tool_context = lambda _ctx: _StubToolCtx()  # type: ignore
    # Ensure clean registry for this test
    from hanzo_mcp.tools.mcp.mcp_add import McpAddTool as _M

    _M._mcp_servers.clear()
    # Remove any persisted registry
    cfg = _M._config_file
    try:
        if cfg.exists():
            cfg.unlink()
    except Exception:
        pass
    add = McpAddTool()
    stats = McpStatsTool()

    server_name = f"linear-{tmp_path.name}"
    res = await add.call(
        ctx,
        command="npx @modelcontextprotocol/server-linear",
        name=server_name,
        args="--help",
        auto_start=False,
    )
    assert f"Successfully added MCP server '{server_name}'" in res

    out = await stats.call(ctx)
    # Stats include common servers hint; ensure linear appears in server details hints
    assert "@modelcontextprotocol/server-linear" in out


@pytest.mark.asyncio
async def test_git_worktree_per_task(monkeypatch, tmp_path: Path):
    """Create per-task git worktrees using the bash tool in a temp repo."""

    # Initialize a git repo
    subprocess.run(["git", "init", "-q", str(tmp_path)], check=True)
    (tmp_path / "README.md").write_text("demo")
    subprocess.run(["git", "-C", str(tmp_path), "add", "README.md"], check=True)
    subprocess.run(
        [
            "git",
            "-C",
            str(tmp_path),
            "commit",
            "-qm",
            "chore: initial",
        ],
        check=True,
    )

    # Prepare bash tool
    ctx = MCPContext()
    pm = PermissionManager()
    pm._allowed_paths.add(str(tmp_path))
    bash = BashTool(permission_manager=pm)

    # Restore real subprocess execution for this test (override auto background mock)
    async def _exec_now(**kwargs):
        cmd_args = kwargs.get("cmd_args")
        cwd = kwargs.get("cwd")
        env = kwargs.get("env")
        proc = subprocess.run(
            cmd_args,
            cwd=str(cwd) if cwd else None,
            env=env,
            capture_output=True,
            text=True,
        )
        if proc.returncode != 0:
            return (
                f"Command failed with exit code {proc.returncode}:\n{proc.stderr}",
                False,
                None,
            )
        return (proc.stdout or "Exit Code: 0", False, None)

    bash.auto_background_executor.execute_with_auto_background = _exec_now  # type: ignore

    # Create two worktrees for two tasks
    tasks = ["init-repo", "add-ci"]
    for t in tasks:
        worktree_dir = tmp_path.parent / f"{tmp_path.name}-{t}"
        cmd = f"git -C {tmp_path} worktree add -b {t} {worktree_dir}"
        res = await bash.call(ctx, command=cmd)
        assert worktree_dir.exists()
        assert worktree_dir.exists()

    # Verify branches exist
    branches = subprocess.run(
        ["git", "-C", str(tmp_path), "branch"],
        capture_output=True,
        text=True,
        check=True,
    ).stdout
    assert "init-repo" in branches and "add-ci" in branches
